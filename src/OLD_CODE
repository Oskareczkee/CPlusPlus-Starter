void Window::KeyEvent(int key, int /*scancode*/, int action, int /*mods*/){
    if(action == GLFW_PRESS){
        switch (key){
            case GLFW_KEY_ESCAPE:
                glfwSetWindowShouldClose(window_, GLFW_TRUE);
            break;
            case GLFW_KEY_LEFT:
              this->show_cube_ ? cube_.SlowDown() : kdron_.SlowDown();
            break;
            case GLFW_KEY_RIGHT:
                this->show_cube_ ? cube_.SpeedUp() : kdron_.SpeedUp();
            break;
            case GLFW_KEY_SPACE:
                this->show_cube_ ? cube_.ToggleAnimated() : kdron_.ToggleAnimated();
            break;

            //switch from kdron to cube and vice versa
            case GLFW_KEY_C:
                this->show_cube_ = !this->show_cube_;
                break;
            default:
                break;
        }
    }
    else if(action == GLFW_REPEAT){
        switch (key){
            case GLFW_KEY_LEFT:
                this->show_cube_ ? cube_.SlowDown() : kdron_.SlowDown();
            break;
            case GLFW_KEY_RIGHT:
                this->show_cube_ ? cube_.SpeedUp() : kdron_.SpeedUp();
            break;
            default:
            break;
        }
    }
}

void Window::Run(void){
    while (!glfwWindowShouldClose(window_)){
        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
        clock_t now = clock();
        if (last_time_ == 0) last_time_ = now;
        this->show_cube_ ? 
                        cube_.Move((float)(now - last_time_) / CLOCKS_PER_SEC):
                        kdron_.Move((float)(now - last_time_) / CLOCKS_PER_SEC);
        last_time_ = now;

        this->show_cube_ ? cube_.Draw(program_) : kdron_.Draw(program_);
        glfwSwapBuffers(window_);
        glfwPollEvents();
    }

}